// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: embeddings.sql

package postgres

import (
	"context"
	"time"

	"github.com/google/uuid"
	pgvector_go "github.com/pgvector/pgvector-go"
)

const listSymbolsWithoutEmbeddings = `-- name: ListSymbolsWithoutEmbeddings :many
SELECT s.id, s.project_id, s.file_id, s.name, s.qualified_name, s.kind, s.language, s.start_line, s.end_line, s.start_col, s.end_col, s.signature, s.doc_comment, s.metadata, s.created_at, s.updated_at FROM symbols s
LEFT JOIN symbol_embeddings se ON s.id = se.symbol_id
WHERE s.project_id = $1 AND se.id IS NULL
`

func (q *Queries) ListSymbolsWithoutEmbeddings(ctx context.Context, projectID uuid.UUID) ([]Symbol, error) {
	rows, err := q.db.Query(ctx, listSymbolsWithoutEmbeddings, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Symbol{}
	for rows.Next() {
		var i Symbol
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.FileID,
			&i.Name,
			&i.QualifiedName,
			&i.Kind,
			&i.Language,
			&i.StartLine,
			&i.EndLine,
			&i.StartCol,
			&i.EndCol,
			&i.Signature,
			&i.DocComment,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const semanticSearch = `-- name: SemanticSearch :many
SELECT s.id, s.project_id, s.file_id, s.name, s.qualified_name, s.kind, s.language, s.start_line, s.end_line, s.start_col, s.end_col, s.signature, s.doc_comment, s.metadata, s.created_at, s.updated_at, (se.embedding <=> $1::vector) AS distance
FROM symbols s
JOIN symbol_embeddings se ON s.id = se.symbol_id
WHERE s.project_id = $2
  AND (cardinality($3::text[]) = 0 OR s.kind = ANY($3::text[]))
ORDER BY se.embedding <=> $1::vector
LIMIT $4
`

type SemanticSearchParams struct {
	QueryEmbedding pgvector_go.Vector `json:"query_embedding"`
	ProjectID      uuid.UUID          `json:"project_id"`
	Kinds          []string           `json:"kinds"`
	Lim            int32              `json:"lim"`
}

type SemanticSearchRow struct {
	ID            uuid.UUID   `json:"id"`
	ProjectID     uuid.UUID   `json:"project_id"`
	FileID        uuid.UUID   `json:"file_id"`
	Name          string      `json:"name"`
	QualifiedName string      `json:"qualified_name"`
	Kind          string      `json:"kind"`
	Language      string      `json:"language"`
	StartLine     int32       `json:"start_line"`
	EndLine       int32       `json:"end_line"`
	StartCol      *int32      `json:"start_col"`
	EndCol        *int32      `json:"end_col"`
	Signature     *string     `json:"signature"`
	DocComment    *string     `json:"doc_comment"`
	Metadata      []byte      `json:"metadata"`
	CreatedAt     time.Time   `json:"created_at"`
	UpdatedAt     time.Time   `json:"updated_at"`
	Distance      interface{} `json:"distance"`
}

func (q *Queries) SemanticSearch(ctx context.Context, arg SemanticSearchParams) ([]SemanticSearchRow, error) {
	rows, err := q.db.Query(ctx, semanticSearch,
		arg.QueryEmbedding,
		arg.ProjectID,
		arg.Kinds,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SemanticSearchRow{}
	for rows.Next() {
		var i SemanticSearchRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.FileID,
			&i.Name,
			&i.QualifiedName,
			&i.Kind,
			&i.Language,
			&i.StartLine,
			&i.EndLine,
			&i.StartCol,
			&i.EndCol,
			&i.Signature,
			&i.DocComment,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertSymbolEmbedding = `-- name: UpsertSymbolEmbedding :exec
INSERT INTO symbol_embeddings (symbol_id, embedding, model)
VALUES ($1, $2, $3)
ON CONFLICT (symbol_id) DO UPDATE SET embedding = $2, model = $3, created_at = now()
`

type UpsertSymbolEmbeddingParams struct {
	SymbolID  uuid.UUID          `json:"symbol_id"`
	Embedding pgvector_go.Vector `json:"embedding"`
	Model     string             `json:"model"`
}

func (q *Queries) UpsertSymbolEmbedding(ctx context.Context, arg UpsertSymbolEmbeddingParams) error {
	_, err := q.db.Exec(ctx, upsertSymbolEmbedding, arg.SymbolID, arg.Embedding, arg.Model)
	return err
}
