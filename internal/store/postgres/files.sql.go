// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: files.sql

package postgres

import (
	"context"

	"github.com/google/uuid"
)

const countFilesByProject = `-- name: CountFilesByProject :one
SELECT count(*) FROM files WHERE project_id = $1
`

func (q *Queries) CountFilesByProject(ctx context.Context, projectID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countFilesByProject, projectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getFile = `-- name: GetFile :one
SELECT id, project_id, source_id, path, language, size_bytes, hash, last_indexed_at, created_at, updated_at FROM files WHERE id = $1
`

func (q *Queries) GetFile(ctx context.Context, id uuid.UUID) (File, error) {
	row := q.db.QueryRow(ctx, getFile, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.SourceID,
		&i.Path,
		&i.Language,
		&i.SizeBytes,
		&i.Hash,
		&i.LastIndexedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFileByPath = `-- name: GetFileByPath :one
SELECT id, project_id, source_id, path, language, size_bytes, hash, last_indexed_at, created_at, updated_at FROM files WHERE project_id = $1 AND source_id = $2 AND path = $3
`

type GetFileByPathParams struct {
	ProjectID uuid.UUID `json:"project_id"`
	SourceID  uuid.UUID `json:"source_id"`
	Path      string    `json:"path"`
}

func (q *Queries) GetFileByPath(ctx context.Context, arg GetFileByPathParams) (File, error) {
	row := q.db.QueryRow(ctx, getFileByPath, arg.ProjectID, arg.SourceID, arg.Path)
	var i File
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.SourceID,
		&i.Path,
		&i.Language,
		&i.SizeBytes,
		&i.Hash,
		&i.LastIndexedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listFilesByProject = `-- name: ListFilesByProject :many
SELECT id, project_id, source_id, path, language, size_bytes, hash, last_indexed_at, created_at, updated_at FROM files WHERE project_id = $1
`

func (q *Queries) ListFilesByProject(ctx context.Context, projectID uuid.UUID) ([]File, error) {
	rows, err := q.db.Query(ctx, listFilesByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.SourceID,
			&i.Path,
			&i.Language,
			&i.SizeBytes,
			&i.Hash,
			&i.LastIndexedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilesBySourceID = `-- name: ListFilesBySourceID :many
SELECT id, project_id, source_id, path, language, size_bytes, hash, last_indexed_at, created_at, updated_at FROM files WHERE source_id = $1
`

func (q *Queries) ListFilesBySourceID(ctx context.Context, sourceID uuid.UUID) ([]File, error) {
	rows, err := q.db.Query(ctx, listFilesBySourceID, sourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.SourceID,
			&i.Path,
			&i.Language,
			&i.SizeBytes,
			&i.Hash,
			&i.LastIndexedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertFile = `-- name: UpsertFile :one
INSERT INTO files (project_id, source_id, path, language, size_bytes, hash, last_indexed_at)
VALUES ($1, $2, $3, $4, $5, $6, now())
ON CONFLICT (project_id, source_id, path) DO UPDATE
SET language = EXCLUDED.language,
    size_bytes = EXCLUDED.size_bytes,
    hash = EXCLUDED.hash,
    last_indexed_at = now(),
    updated_at = now()
RETURNING id, project_id, source_id, path, language, size_bytes, hash, last_indexed_at, created_at, updated_at
`

type UpsertFileParams struct {
	ProjectID uuid.UUID `json:"project_id"`
	SourceID  uuid.UUID `json:"source_id"`
	Path      string    `json:"path"`
	Language  string    `json:"language"`
	SizeBytes int64     `json:"size_bytes"`
	Hash      string    `json:"hash"`
}

func (q *Queries) UpsertFile(ctx context.Context, arg UpsertFileParams) (File, error) {
	row := q.db.QueryRow(ctx, upsertFile,
		arg.ProjectID,
		arg.SourceID,
		arg.Path,
		arg.Language,
		arg.SizeBytes,
		arg.Hash,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.SourceID,
		&i.Path,
		&i.Language,
		&i.SizeBytes,
		&i.Hash,
		&i.LastIndexedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
