// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: analytics.sql

package postgres

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const batchUpdateSymbolMetadata = `-- name: BatchUpdateSymbolMetadata :exec
UPDATE symbols
SET metadata = metadata || $1::jsonb,
    updated_at = now()
WHERE id = ANY($2::uuid[])
`

type BatchUpdateSymbolMetadataParams struct {
	AnalyticsJson []byte      `json:"analytics_json"`
	SymbolIds     []uuid.UUID `json:"symbol_ids"`
}

// Batch update symbol metadata for a set of symbols
func (q *Queries) BatchUpdateSymbolMetadata(ctx context.Context, arg BatchUpdateSymbolMetadataParams) error {
	_, err := q.db.Exec(ctx, batchUpdateSymbolMetadata, arg.AnalyticsJson, arg.SymbolIds)
	return err
}

const countSymbolsByLayer = `-- name: CountSymbolsByLayer :many
SELECT metadata->>'layer' AS layer, count(*) AS cnt
FROM symbols
WHERE project_id = $1
  AND metadata ? 'layer'
GROUP BY metadata->>'layer'
ORDER BY cnt DESC
`

type CountSymbolsByLayerRow struct {
	Layer interface{} `json:"layer"`
	Cnt   int64       `json:"cnt"`
}

// Count symbols by layer
func (q *Queries) CountSymbolsByLayer(ctx context.Context, projectID uuid.UUID) ([]CountSymbolsByLayerRow, error) {
	rows, err := q.db.Query(ctx, countSymbolsByLayer, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountSymbolsByLayerRow{}
	for rows.Next() {
		var i CountSymbolsByLayerRow
		if err := rows.Scan(&i.Layer, &i.Cnt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteProjectAnalytics = `-- name: DeleteProjectAnalytics :exec
DELETE FROM project_analytics WHERE project_id = $1
`

func (q *Queries) DeleteProjectAnalytics(ctx context.Context, projectID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProjectAnalytics, projectID)
	return err
}

const getCrossLanguageBridges = `-- name: GetCrossLanguageBridges :many
SELECT
    s1.language AS source_language,
    s2.language AS target_language,
    e.edge_type,
    count(*) AS edge_count,
    array_agg(DISTINCT s1.id) AS source_symbol_ids,
    array_agg(DISTINCT s2.id) AS target_symbol_ids
FROM symbol_edges e
JOIN symbols s1 ON e.source_id = s1.id
JOIN symbols s2 ON e.target_id = s2.id
WHERE e.project_id = $1 AND s1.language != s2.language
GROUP BY s1.language, s2.language, e.edge_type
ORDER BY edge_count DESC
`

type GetCrossLanguageBridgesRow struct {
	SourceLanguage  string      `json:"source_language"`
	TargetLanguage  string      `json:"target_language"`
	EdgeType        string      `json:"edge_type"`
	EdgeCount       int64       `json:"edge_count"`
	SourceSymbolIds interface{} `json:"source_symbol_ids"`
	TargetSymbolIds interface{} `json:"target_symbol_ids"`
}

// Cross-language bridge query: edges where source and target have different languages
func (q *Queries) GetCrossLanguageBridges(ctx context.Context, projectID uuid.UUID) ([]GetCrossLanguageBridgesRow, error) {
	rows, err := q.db.Query(ctx, getCrossLanguageBridges, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCrossLanguageBridgesRow{}
	for rows.Next() {
		var i GetCrossLanguageBridgesRow
		if err := rows.Scan(
			&i.SourceLanguage,
			&i.TargetLanguage,
			&i.EdgeType,
			&i.EdgeCount,
			&i.SourceSymbolIds,
			&i.TargetSymbolIds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEdgeList = `-- name: GetEdgeList :many
SELECT source_id, target_id FROM symbol_edges WHERE project_id = $1
`

type GetEdgeListRow struct {
	SourceID uuid.UUID `json:"source_id"`
	TargetID uuid.UUID `json:"target_id"`
}

// Get edge list for PageRank computation
func (q *Queries) GetEdgeList(ctx context.Context, projectID uuid.UUID) ([]GetEdgeListRow, error) {
	rows, err := q.db.Query(ctx, getEdgeList, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEdgeListRow{}
	for rows.Next() {
		var i GetEdgeListRow
		if err := rows.Scan(&i.SourceID, &i.TargetID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNamespaceStats = `-- name: GetNamespaceStats :many
SELECT
    CASE
        WHEN position('.' IN qualified_name) > 0
        THEN left(qualified_name, length(qualified_name) - length(name) - 1)
        ELSE '(root)'
    END AS namespace,
    count(*) AS symbol_count,
    array_agg(DISTINCT kind) AS kinds,
    array_agg(DISTINCT language) AS languages
FROM symbols
WHERE project_id = $1
GROUP BY namespace
HAVING count(*) >= 2
ORDER BY symbol_count DESC
LIMIT $2
`

type GetNamespaceStatsParams struct {
	ProjectID uuid.UUID `json:"project_id"`
	Limit     int32     `json:"limit"`
}

type GetNamespaceStatsRow struct {
	Namespace   string      `json:"namespace"`
	SymbolCount int64       `json:"symbol_count"`
	Kinds       interface{} `json:"kinds"`
	Languages   interface{} `json:"languages"`
}

// Namespace-level stats (extract namespace from qualified_name)
func (q *Queries) GetNamespaceStats(ctx context.Context, arg GetNamespaceStatsParams) ([]GetNamespaceStatsRow, error) {
	rows, err := q.db.Query(ctx, getNamespaceStats, arg.ProjectID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNamespaceStatsRow{}
	for rows.Next() {
		var i GetNamespaceStatsRow
		if err := rows.Scan(
			&i.Namespace,
			&i.SymbolCount,
			&i.Kinds,
			&i.Languages,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getParserCoverage = `-- name: GetParserCoverage :many
SELECT
    f.source_id,
    count(DISTINCT f.id) AS total_files,
    count(DISTINCT s.file_id) AS parsed_files
FROM files f
LEFT JOIN symbols s ON f.id = s.file_id
WHERE f.project_id = $1
GROUP BY f.source_id
`

type GetParserCoverageRow struct {
	SourceID    uuid.UUID `json:"source_id"`
	TotalFiles  int64     `json:"total_files"`
	ParsedFiles int64     `json:"parsed_files"`
}

// Parser coverage: total files vs. files with at least one symbol per source
func (q *Queries) GetParserCoverage(ctx context.Context, projectID uuid.UUID) ([]GetParserCoverageRow, error) {
	rows, err := q.db.Query(ctx, getParserCoverage, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetParserCoverageRow{}
	for rows.Next() {
		var i GetParserCoverageRow
		if err := rows.Scan(&i.SourceID, &i.TotalFiles, &i.ParsedFiles); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectAnalytics = `-- name: GetProjectAnalytics :one
SELECT id, project_id, scope, scope_id, analytics, summary, computed_at FROM project_analytics
WHERE project_id = $1 AND scope = $2 AND scope_id = $3
`

type GetProjectAnalyticsParams struct {
	ProjectID uuid.UUID `json:"project_id"`
	Scope     string    `json:"scope"`
	ScopeID   string    `json:"scope_id"`
}

func (q *Queries) GetProjectAnalytics(ctx context.Context, arg GetProjectAnalyticsParams) (ProjectAnalytic, error) {
	row := q.db.QueryRow(ctx, getProjectAnalytics, arg.ProjectID, arg.Scope, arg.ScopeID)
	var i ProjectAnalytic
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Scope,
		&i.ScopeID,
		&i.Analytics,
		&i.Summary,
		&i.ComputedAt,
	)
	return i, err
}

const getProjectSymbolStats = `-- name: GetProjectSymbolStats :one
SELECT
    count(*) AS total_symbols,
    count(DISTINCT language) AS language_count,
    count(DISTINCT kind) AS kind_count,
    count(DISTINCT file_id) AS file_count
FROM symbols WHERE project_id = $1
`

type GetProjectSymbolStatsRow struct {
	TotalSymbols  int64 `json:"total_symbols"`
	LanguageCount int64 `json:"language_count"`
	KindCount     int64 `json:"kind_count"`
	FileCount     int64 `json:"file_count"`
}

// Project-level aggregate stats
func (q *Queries) GetProjectSymbolStats(ctx context.Context, projectID uuid.UUID) (GetProjectSymbolStatsRow, error) {
	row := q.db.QueryRow(ctx, getProjectSymbolStats, projectID)
	var i GetProjectSymbolStatsRow
	err := row.Scan(
		&i.TotalSymbols,
		&i.LanguageCount,
		&i.KindCount,
		&i.FileCount,
	)
	return i, err
}

const getSourceSymbolStats = `-- name: GetSourceSymbolStats :many
SELECT
    f.source_id,
    count(DISTINCT s.id) AS symbol_count,
    count(DISTINCT f.id) AS file_count,
    count(DISTINCT s.language) AS language_count,
    array_agg(DISTINCT s.language) AS languages,
    array_agg(DISTINCT s.kind) AS kinds
FROM symbols s
JOIN files f ON s.file_id = f.id
WHERE s.project_id = $1
GROUP BY f.source_id
`

type GetSourceSymbolStatsRow struct {
	SourceID      uuid.UUID   `json:"source_id"`
	SymbolCount   int64       `json:"symbol_count"`
	FileCount     int64       `json:"file_count"`
	LanguageCount int64       `json:"language_count"`
	Languages     interface{} `json:"languages"`
	Kinds         interface{} `json:"kinds"`
}

// Source-level stats
func (q *Queries) GetSourceSymbolStats(ctx context.Context, projectID uuid.UUID) ([]GetSourceSymbolStatsRow, error) {
	rows, err := q.db.Query(ctx, getSourceSymbolStats, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSourceSymbolStatsRow{}
	for rows.Next() {
		var i GetSourceSymbolStatsRow
		if err := rows.Scan(
			&i.SourceID,
			&i.SymbolCount,
			&i.FileCount,
			&i.LanguageCount,
			&i.Languages,
			&i.Kinds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSymbolCountsByKind = `-- name: GetSymbolCountsByKind :many
SELECT kind, count(*) AS cnt
FROM symbols WHERE project_id = $1
GROUP BY kind ORDER BY cnt DESC
`

type GetSymbolCountsByKindRow struct {
	Kind string `json:"kind"`
	Cnt  int64  `json:"cnt"`
}

// Symbols grouped by kind
func (q *Queries) GetSymbolCountsByKind(ctx context.Context, projectID uuid.UUID) ([]GetSymbolCountsByKindRow, error) {
	rows, err := q.db.Query(ctx, getSymbolCountsByKind, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSymbolCountsByKindRow{}
	for rows.Next() {
		var i GetSymbolCountsByKindRow
		if err := rows.Scan(&i.Kind, &i.Cnt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSymbolCountsByLanguage = `-- name: GetSymbolCountsByLanguage :many
SELECT language, count(*) AS cnt
FROM symbols WHERE project_id = $1
GROUP BY language ORDER BY cnt DESC
`

type GetSymbolCountsByLanguageRow struct {
	Language string `json:"language"`
	Cnt      int64  `json:"cnt"`
}

// Symbols grouped by language
func (q *Queries) GetSymbolCountsByLanguage(ctx context.Context, projectID uuid.UUID) ([]GetSymbolCountsByLanguageRow, error) {
	rows, err := q.db.Query(ctx, getSymbolCountsByLanguage, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSymbolCountsByLanguageRow{}
	for rows.Next() {
		var i GetSymbolCountsByLanguageRow
		if err := rows.Scan(&i.Language, &i.Cnt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSymbolDegrees = `-- name: GetSymbolDegrees :many
SELECT
    s.id,
    COALESCE(inc.cnt, 0)::int AS in_degree,
    COALESCE(outc.cnt, 0)::int AS out_degree
FROM symbols s
LEFT JOIN (
    SELECT se.target_id, count(*) AS cnt
    FROM symbol_edges se WHERE se.project_id = $1
    GROUP BY se.target_id
) inc ON s.id = inc.target_id
LEFT JOIN (
    SELECT se2.source_id, count(*) AS cnt
    FROM symbol_edges se2 WHERE se2.project_id = $1
    GROUP BY se2.source_id
) outc ON s.id = outc.source_id
WHERE s.project_id = $1
`

type GetSymbolDegreesRow struct {
	ID        uuid.UUID `json:"id"`
	InDegree  int32     `json:"in_degree"`
	OutDegree int32     `json:"out_degree"`
}

// Degree computation: count in-degree and out-degree per symbol
func (q *Queries) GetSymbolDegrees(ctx context.Context, projectID uuid.UUID) ([]GetSymbolDegreesRow, error) {
	rows, err := q.db.Query(ctx, getSymbolDegrees, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSymbolDegreesRow{}
	for rows.Next() {
		var i GetSymbolDegreesRow
		if err := rows.Scan(&i.ID, &i.InDegree, &i.OutDegree); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSymbolsByLayer = `-- name: GetSymbolsByLayer :many
SELECT id, project_id, file_id, name, qualified_name, kind, language, start_line, end_line, start_col, end_col, signature, doc_comment, metadata, created_at, updated_at FROM symbols
WHERE project_id = $1
  AND metadata->>'layer' = $2
ORDER BY qualified_name
LIMIT $3 OFFSET $4
`

type GetSymbolsByLayerParams struct {
	ProjectID uuid.UUID `json:"project_id"`
	Metadata  []byte    `json:"metadata"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

// Symbols by layer
func (q *Queries) GetSymbolsByLayer(ctx context.Context, arg GetSymbolsByLayerParams) ([]Symbol, error) {
	rows, err := q.db.Query(ctx, getSymbolsByLayer,
		arg.ProjectID,
		arg.Metadata,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Symbol{}
	for rows.Next() {
		var i Symbol
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.FileID,
			&i.Name,
			&i.QualifiedName,
			&i.Kind,
			&i.Language,
			&i.StartLine,
			&i.EndLine,
			&i.StartCol,
			&i.EndCol,
			&i.Signature,
			&i.DocComment,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllProjectAnalytics = `-- name: ListAllProjectAnalytics :many
SELECT id, project_id, scope, scope_id, analytics, summary, computed_at FROM project_analytics
WHERE project_id = $1
ORDER BY scope, scope_id
`

func (q *Queries) ListAllProjectAnalytics(ctx context.Context, projectID uuid.UUID) ([]ProjectAnalytic, error) {
	rows, err := q.db.Query(ctx, listAllProjectAnalytics, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProjectAnalytic{}
	for rows.Next() {
		var i ProjectAnalytic
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Scope,
			&i.ScopeID,
			&i.Analytics,
			&i.Summary,
			&i.ComputedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectAnalyticsByScope = `-- name: ListProjectAnalyticsByScope :many
SELECT id, project_id, scope, scope_id, analytics, summary, computed_at FROM project_analytics
WHERE project_id = $1 AND scope = $2
ORDER BY scope_id
`

type ListProjectAnalyticsByScopeParams struct {
	ProjectID uuid.UUID `json:"project_id"`
	Scope     string    `json:"scope"`
}

func (q *Queries) ListProjectAnalyticsByScope(ctx context.Context, arg ListProjectAnalyticsByScopeParams) ([]ProjectAnalytic, error) {
	rows, err := q.db.Query(ctx, listProjectAnalyticsByScope, arg.ProjectID, arg.Scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProjectAnalytic{}
	for rows.Next() {
		var i ProjectAnalytic
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Scope,
			&i.ScopeID,
			&i.Analytics,
			&i.Summary,
			&i.ComputedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const topSymbolsByInDegree = `-- name: TopSymbolsByInDegree :many
SELECT s.id, s.project_id, s.file_id, s.name, s.qualified_name, s.kind, s.language, s.start_line, s.end_line, s.start_col, s.end_col, s.signature, s.doc_comment, s.metadata, s.created_at, s.updated_at, (s.metadata->>'in_degree')::int AS in_degree
FROM symbols s
WHERE s.project_id = $1
  AND s.metadata ? 'in_degree'
  AND (s.metadata->>'in_degree')::int > 0
ORDER BY (s.metadata->>'in_degree')::int DESC
LIMIT $2
`

type TopSymbolsByInDegreeParams struct {
	ProjectID uuid.UUID `json:"project_id"`
	Limit     int32     `json:"limit"`
}

type TopSymbolsByInDegreeRow struct {
	ID            uuid.UUID `json:"id"`
	ProjectID     uuid.UUID `json:"project_id"`
	FileID        uuid.UUID `json:"file_id"`
	Name          string    `json:"name"`
	QualifiedName string    `json:"qualified_name"`
	Kind          string    `json:"kind"`
	Language      string    `json:"language"`
	StartLine     int32     `json:"start_line"`
	EndLine       int32     `json:"end_line"`
	StartCol      *int32    `json:"start_col"`
	EndCol        *int32    `json:"end_col"`
	Signature     *string   `json:"signature"`
	DocComment    *string   `json:"doc_comment"`
	Metadata      []byte    `json:"metadata"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
	InDegree      int32     `json:"in_degree"`
}

// Top symbols by in-degree (most depended-upon)
func (q *Queries) TopSymbolsByInDegree(ctx context.Context, arg TopSymbolsByInDegreeParams) ([]TopSymbolsByInDegreeRow, error) {
	rows, err := q.db.Query(ctx, topSymbolsByInDegree, arg.ProjectID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TopSymbolsByInDegreeRow{}
	for rows.Next() {
		var i TopSymbolsByInDegreeRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.FileID,
			&i.Name,
			&i.QualifiedName,
			&i.Kind,
			&i.Language,
			&i.StartLine,
			&i.EndLine,
			&i.StartCol,
			&i.EndCol,
			&i.Signature,
			&i.DocComment,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.InDegree,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const topSymbolsByPageRank = `-- name: TopSymbolsByPageRank :many
SELECT s.id, s.project_id, s.file_id, s.name, s.qualified_name, s.kind, s.language, s.start_line, s.end_line, s.start_col, s.end_col, s.signature, s.doc_comment, s.metadata, s.created_at, s.updated_at, (s.metadata->>'pagerank')::float AS pagerank
FROM symbols s
WHERE s.project_id = $1
  AND s.metadata ? 'pagerank'
ORDER BY (s.metadata->>'pagerank')::float DESC
LIMIT $2
`

type TopSymbolsByPageRankParams struct {
	ProjectID uuid.UUID `json:"project_id"`
	Limit     int32     `json:"limit"`
}

type TopSymbolsByPageRankRow struct {
	ID            uuid.UUID `json:"id"`
	ProjectID     uuid.UUID `json:"project_id"`
	FileID        uuid.UUID `json:"file_id"`
	Name          string    `json:"name"`
	QualifiedName string    `json:"qualified_name"`
	Kind          string    `json:"kind"`
	Language      string    `json:"language"`
	StartLine     int32     `json:"start_line"`
	EndLine       int32     `json:"end_line"`
	StartCol      *int32    `json:"start_col"`
	EndCol        *int32    `json:"end_col"`
	Signature     *string   `json:"signature"`
	DocComment    *string   `json:"doc_comment"`
	Metadata      []byte    `json:"metadata"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
	Pagerank      float64   `json:"pagerank"`
}

// Top symbols by PageRank
func (q *Queries) TopSymbolsByPageRank(ctx context.Context, arg TopSymbolsByPageRankParams) ([]TopSymbolsByPageRankRow, error) {
	rows, err := q.db.Query(ctx, topSymbolsByPageRank, arg.ProjectID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TopSymbolsByPageRankRow{}
	for rows.Next() {
		var i TopSymbolsByPageRankRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.FileID,
			&i.Name,
			&i.QualifiedName,
			&i.Kind,
			&i.Language,
			&i.StartLine,
			&i.EndLine,
			&i.StartCol,
			&i.EndCol,
			&i.Signature,
			&i.DocComment,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Pagerank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSymbolMetadata = `-- name: UpdateSymbolMetadata :exec
UPDATE symbols
SET metadata = metadata || $1::jsonb,
    updated_at = now()
WHERE id = $2
`

type UpdateSymbolMetadataParams struct {
	AnalyticsJson []byte    `json:"analytics_json"`
	SymbolID      uuid.UUID `json:"symbol_id"`
}

// Update symbol metadata with computed analytics (degree, pagerank, layer)
func (q *Queries) UpdateSymbolMetadata(ctx context.Context, arg UpdateSymbolMetadataParams) error {
	_, err := q.db.Exec(ctx, updateSymbolMetadata, arg.AnalyticsJson, arg.SymbolID)
	return err
}

const upsertProjectAnalytics = `-- name: UpsertProjectAnalytics :one
INSERT INTO project_analytics (project_id, scope, scope_id, analytics, summary, computed_at)
VALUES ($1, $2, $3, $4, $5, now())
ON CONFLICT (project_id, scope, scope_id) DO UPDATE
SET analytics = EXCLUDED.analytics,
    summary = EXCLUDED.summary,
    computed_at = now()
RETURNING id, project_id, scope, scope_id, analytics, summary, computed_at
`

type UpsertProjectAnalyticsParams struct {
	ProjectID uuid.UUID `json:"project_id"`
	Scope     string    `json:"scope"`
	ScopeID   string    `json:"scope_id"`
	Analytics []byte    `json:"analytics"`
	Summary   *string   `json:"summary"`
}

func (q *Queries) UpsertProjectAnalytics(ctx context.Context, arg UpsertProjectAnalyticsParams) (ProjectAnalytic, error) {
	row := q.db.QueryRow(ctx, upsertProjectAnalytics,
		arg.ProjectID,
		arg.Scope,
		arg.ScopeID,
		arg.Analytics,
		arg.Summary,
	)
	var i ProjectAnalytic
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Scope,
		&i.ScopeID,
		&i.Analytics,
		&i.Summary,
		&i.ComputedAt,
	)
	return i, err
}
