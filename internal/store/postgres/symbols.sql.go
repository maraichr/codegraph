// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: symbols.sql

package postgres

import (
	"context"

	"github.com/google/uuid"
)

const countSymbolsByProject = `-- name: CountSymbolsByProject :one
SELECT count(*) FROM symbols WHERE project_id = $1
`

func (q *Queries) CountSymbolsByProject(ctx context.Context, projectID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSymbolsByProject, projectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSymbol = `-- name: CreateSymbol :one
INSERT INTO symbols (project_id, file_id, name, qualified_name, kind, language, start_line, end_line, start_col, end_col, signature, doc_comment)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
ON CONFLICT (project_id, qualified_name, kind) DO UPDATE SET
    file_id = EXCLUDED.file_id,
    name = EXCLUDED.name,
    language = EXCLUDED.language,
    start_line = EXCLUDED.start_line,
    end_line = EXCLUDED.end_line,
    start_col = EXCLUDED.start_col,
    end_col = EXCLUDED.end_col,
    signature = EXCLUDED.signature,
    doc_comment = EXCLUDED.doc_comment,
    updated_at = now()
RETURNING id, project_id, file_id, name, qualified_name, kind, language, start_line, end_line, start_col, end_col, signature, doc_comment, metadata, created_at, updated_at
`

type CreateSymbolParams struct {
	ProjectID     uuid.UUID `json:"project_id"`
	FileID        uuid.UUID `json:"file_id"`
	Name          string    `json:"name"`
	QualifiedName string    `json:"qualified_name"`
	Kind          string    `json:"kind"`
	Language      string    `json:"language"`
	StartLine     int32     `json:"start_line"`
	EndLine       int32     `json:"end_line"`
	StartCol      *int32    `json:"start_col"`
	EndCol        *int32    `json:"end_col"`
	Signature     *string   `json:"signature"`
	DocComment    *string   `json:"doc_comment"`
}

func (q *Queries) CreateSymbol(ctx context.Context, arg CreateSymbolParams) (Symbol, error) {
	row := q.db.QueryRow(ctx, createSymbol,
		arg.ProjectID,
		arg.FileID,
		arg.Name,
		arg.QualifiedName,
		arg.Kind,
		arg.Language,
		arg.StartLine,
		arg.EndLine,
		arg.StartCol,
		arg.EndCol,
		arg.Signature,
		arg.DocComment,
	)
	var i Symbol
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.FileID,
		&i.Name,
		&i.QualifiedName,
		&i.Kind,
		&i.Language,
		&i.StartLine,
		&i.EndLine,
		&i.StartCol,
		&i.EndCol,
		&i.Signature,
		&i.DocComment,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSymbolsByFile = `-- name: DeleteSymbolsByFile :exec
DELETE FROM symbols WHERE file_id = $1
`

func (q *Queries) DeleteSymbolsByFile(ctx context.Context, fileID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSymbolsByFile, fileID)
	return err
}

const deleteSymbolsByFileID = `-- name: DeleteSymbolsByFileID :exec
DELETE FROM symbols WHERE file_id = $1
`

func (q *Queries) DeleteSymbolsByFileID(ctx context.Context, fileID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSymbolsByFileID, fileID)
	return err
}

const getSymbol = `-- name: GetSymbol :one
SELECT id, project_id, file_id, name, qualified_name, kind, language, start_line, end_line, start_col, end_col, signature, doc_comment, metadata, created_at, updated_at FROM symbols WHERE id = $1
`

func (q *Queries) GetSymbol(ctx context.Context, id uuid.UUID) (Symbol, error) {
	row := q.db.QueryRow(ctx, getSymbol, id)
	var i Symbol
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.FileID,
		&i.Name,
		&i.QualifiedName,
		&i.Kind,
		&i.Language,
		&i.StartLine,
		&i.EndLine,
		&i.StartCol,
		&i.EndCol,
		&i.Signature,
		&i.DocComment,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSymbolByQualifiedName = `-- name: GetSymbolByQualifiedName :one
SELECT id, project_id, file_id, name, qualified_name, kind, language, start_line, end_line, start_col, end_col, signature, doc_comment, metadata, created_at, updated_at FROM symbols WHERE project_id = $1 AND qualified_name = $2
`

type GetSymbolByQualifiedNameParams struct {
	ProjectID     uuid.UUID `json:"project_id"`
	QualifiedName string    `json:"qualified_name"`
}

func (q *Queries) GetSymbolByQualifiedName(ctx context.Context, arg GetSymbolByQualifiedNameParams) (Symbol, error) {
	row := q.db.QueryRow(ctx, getSymbolByQualifiedName, arg.ProjectID, arg.QualifiedName)
	var i Symbol
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.FileID,
		&i.Name,
		&i.QualifiedName,
		&i.Kind,
		&i.Language,
		&i.StartLine,
		&i.EndLine,
		&i.StartCol,
		&i.EndCol,
		&i.Signature,
		&i.DocComment,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSymbolsByProject = `-- name: GetSymbolsByProject :many
SELECT id, project_id, file_id, name, qualified_name, kind, language, start_line, end_line, start_col, end_col, signature, doc_comment, metadata, created_at, updated_at FROM symbols WHERE project_id = $1 ORDER BY qualified_name LIMIT $2 OFFSET $3
`

type GetSymbolsByProjectParams struct {
	ProjectID uuid.UUID `json:"project_id"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

func (q *Queries) GetSymbolsByProject(ctx context.Context, arg GetSymbolsByProjectParams) ([]Symbol, error) {
	rows, err := q.db.Query(ctx, getSymbolsByProject, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Symbol{}
	for rows.Next() {
		var i Symbol
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.FileID,
			&i.Name,
			&i.QualifiedName,
			&i.Kind,
			&i.Language,
			&i.StartLine,
			&i.EndLine,
			&i.StartCol,
			&i.EndCol,
			&i.Signature,
			&i.DocComment,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listColumnSymbolsByProject = `-- name: ListColumnSymbolsByProject :many
SELECT id, project_id, file_id, name, qualified_name, kind, language, start_line, end_line, start_col, end_col, signature, doc_comment, metadata, created_at, updated_at FROM symbols WHERE project_id = $1 AND kind = 'column'
`

func (q *Queries) ListColumnSymbolsByProject(ctx context.Context, projectID uuid.UUID) ([]Symbol, error) {
	rows, err := q.db.Query(ctx, listColumnSymbolsByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Symbol{}
	for rows.Next() {
		var i Symbol
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.FileID,
			&i.Name,
			&i.QualifiedName,
			&i.Kind,
			&i.Language,
			&i.StartLine,
			&i.EndLine,
			&i.StartCol,
			&i.EndCol,
			&i.Signature,
			&i.DocComment,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSymbolsByFileIDs = `-- name: ListSymbolsByFileIDs :many
SELECT id, project_id, file_id, name, qualified_name, kind, language, start_line, end_line, start_col, end_col, signature, doc_comment, metadata, created_at, updated_at FROM symbols WHERE file_id = ANY($1::uuid[])
`

func (q *Queries) ListSymbolsByFileIDs(ctx context.Context, dollar_1 []uuid.UUID) ([]Symbol, error) {
	rows, err := q.db.Query(ctx, listSymbolsByFileIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Symbol{}
	for rows.Next() {
		var i Symbol
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.FileID,
			&i.Name,
			&i.QualifiedName,
			&i.Kind,
			&i.Language,
			&i.StartLine,
			&i.EndLine,
			&i.StartCol,
			&i.EndCol,
			&i.Signature,
			&i.DocComment,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSymbolsByNames = `-- name: ListSymbolsByNames :many
SELECT id, project_id, file_id, name, qualified_name, kind, language, start_line, end_line, start_col, end_col, signature, doc_comment, metadata, created_at, updated_at FROM symbols WHERE project_id = $1 AND name = ANY($2::text[])
`

type ListSymbolsByNamesParams struct {
	ProjectID uuid.UUID `json:"project_id"`
	Column2   []string  `json:"column_2"`
}

func (q *Queries) ListSymbolsByNames(ctx context.Context, arg ListSymbolsByNamesParams) ([]Symbol, error) {
	rows, err := q.db.Query(ctx, listSymbolsByNames, arg.ProjectID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Symbol{}
	for rows.Next() {
		var i Symbol
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.FileID,
			&i.Name,
			&i.QualifiedName,
			&i.Kind,
			&i.Language,
			&i.StartLine,
			&i.EndLine,
			&i.StartCol,
			&i.EndCol,
			&i.Signature,
			&i.DocComment,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSymbolsByProject = `-- name: ListSymbolsByProject :many
SELECT id, project_id, file_id, name, qualified_name, kind, language, start_line, end_line, start_col, end_col, signature, doc_comment, metadata, created_at, updated_at FROM symbols WHERE project_id = $1
`

func (q *Queries) ListSymbolsByProject(ctx context.Context, projectID uuid.UUID) ([]Symbol, error) {
	rows, err := q.db.Query(ctx, listSymbolsByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Symbol{}
	for rows.Next() {
		var i Symbol
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.FileID,
			&i.Name,
			&i.QualifiedName,
			&i.Kind,
			&i.Language,
			&i.StartLine,
			&i.EndLine,
			&i.StartCol,
			&i.EndCol,
			&i.Signature,
			&i.DocComment,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTopSymbolsByKind = `-- name: ListTopSymbolsByKind :many
SELECT id, project_id, file_id, name, qualified_name, kind, language, start_line, end_line, start_col, end_col, signature, doc_comment, metadata, created_at, updated_at FROM symbols
WHERE project_id = (SELECT id FROM projects WHERE slug = $1)
  AND (cardinality($2::text[]) = 0 OR kind = ANY($2::text[]))
  AND (cardinality($3::text[]) = 0 OR language = ANY($3::text[]))
ORDER BY (COALESCE(metadata->>'in_degree', '0'))::int DESC
LIMIT $4
`

type ListTopSymbolsByKindParams struct {
	ProjectSlug string   `json:"project_slug"`
	Kinds       []string `json:"kinds"`
	Languages   []string `json:"languages"`
	Lim         int32    `json:"lim"`
}

func (q *Queries) ListTopSymbolsByKind(ctx context.Context, arg ListTopSymbolsByKindParams) ([]Symbol, error) {
	rows, err := q.db.Query(ctx, listTopSymbolsByKind,
		arg.ProjectSlug,
		arg.Kinds,
		arg.Languages,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Symbol{}
	for rows.Next() {
		var i Symbol
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.FileID,
			&i.Name,
			&i.QualifiedName,
			&i.Kind,
			&i.Language,
			&i.StartLine,
			&i.EndLine,
			&i.StartCol,
			&i.EndCol,
			&i.Signature,
			&i.DocComment,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSymbols = `-- name: SearchSymbols :many
SELECT id, project_id, file_id, name, qualified_name, kind, language, start_line, end_line, start_col, end_col, signature, doc_comment, metadata, created_at, updated_at FROM symbols
WHERE project_id = (SELECT id FROM projects WHERE slug = $1)
  AND (name ILIKE '%' || $2 || '%' OR qualified_name ILIKE '%' || $2 || '%')
  AND (cardinality($3::text[]) = 0 OR kind = ANY($3::text[]))
  AND (cardinality($4::text[]) = 0 OR language = ANY($4::text[]))
ORDER BY name
LIMIT $5
`

type SearchSymbolsParams struct {
	ProjectSlug string   `json:"project_slug"`
	Query       *string  `json:"query"`
	Kinds       []string `json:"kinds"`
	Languages   []string `json:"languages"`
	Lim         int32    `json:"lim"`
}

func (q *Queries) SearchSymbols(ctx context.Context, arg SearchSymbolsParams) ([]Symbol, error) {
	rows, err := q.db.Query(ctx, searchSymbols,
		arg.ProjectSlug,
		arg.Query,
		arg.Kinds,
		arg.Languages,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Symbol{}
	for rows.Next() {
		var i Symbol
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.FileID,
			&i.Name,
			&i.QualifiedName,
			&i.Kind,
			&i.Language,
			&i.StartLine,
			&i.EndLine,
			&i.StartCol,
			&i.EndCol,
			&i.Signature,
			&i.DocComment,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
