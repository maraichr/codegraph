package graphql

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"strings"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	pgvector "github.com/pgvector/pgvector-go"

	"github.com/maraichr/codegraph/internal/auth"
	"github.com/maraichr/codegraph/internal/store/postgres"
	"github.com/maraichr/codegraph/pkg/apierr"
	"github.com/maraichr/codegraph/pkg/models"
)

// ID is the resolver for the id field.
func (r *fileResolver) ID(ctx context.Context, obj *models.File) (string, error) {
	return obj.ID.String(), nil
}

// CreateProject is the resolver for the createProject field.
func (r *mutationResolver) CreateProject(ctx context.Context, input CreateProjectInput) (*Project, error) {
	principal, _ := auth.PrincipalFrom(ctx)
	p, err := r.Store.CreateProject(ctx, postgres.CreateProjectParams{
		Name:        input.Name,
		Slug:        input.Slug,
		Description: input.Description,
		TenantID:    principal.TenantID,
	})
	if err != nil {
		return nil, apierr.ProjectCreateFailed(err)
	}
	return dbProjectToGQL(p), nil
}

// UpdateProject is the resolver for the updateProject field.
func (r *mutationResolver) UpdateProject(ctx context.Context, slug string, input UpdateProjectInput) (*Project, error) {
	current, err := r.Store.GetProject(ctx, slug)
	if err != nil {
		if apierr.IsNotFound(err) {
			return nil, apierr.ProjectNotFound()
		}
		return nil, apierr.InternalError(err)
	}

	name := current.Name
	if input.Name != nil {
		name = *input.Name
	}
	desc := current.Description
	if input.Description != nil {
		desc = input.Description
	}

	p, err := r.Store.UpdateProject(ctx, postgres.UpdateProjectParams{
		Slug:        slug,
		Name:        name,
		Description: desc,
		Settings:    current.Settings,
	})
	if err != nil {
		return nil, apierr.ProjectUpdateFailed(err)
	}
	return dbProjectToGQL(p), nil
}

// DeleteProject is the resolver for the deleteProject field.
func (r *mutationResolver) DeleteProject(ctx context.Context, slug string) (bool, error) {
	if err := r.Store.DeleteProject(ctx, slug); err != nil {
		return false, apierr.ProjectDeleteFailed(err)
	}
	return true, nil
}

// CreateSource is the resolver for the createSource field.
func (r *mutationResolver) CreateSource(ctx context.Context, projectSlug string, input CreateSourceInput) (*Source, error) {
	project, err := r.Store.GetProject(ctx, projectSlug)
	if err != nil {
		if apierr.IsNotFound(err) {
			return nil, apierr.ProjectNotFound()
		}
		return nil, apierr.InternalError(err)
	}

	configBytes := []byte("{}")
	if input.Config != nil {
		configBytes = []byte(*input.Config)
	}

	s, err := r.Store.CreateSource(ctx, postgres.CreateSourceParams{
		ProjectID:     project.ID,
		Name:          input.Name,
		SourceType:    strings.ToLower(input.SourceType.String()),
		ConnectionUri: input.ConnectionURI,
		Config:        configBytes,
	})
	if err != nil {
		return nil, apierr.SourceCreateFailed(err)
	}
	return dbSourceToGQL(s), nil
}

// DeleteSource is the resolver for the deleteSource field.
func (r *mutationResolver) DeleteSource(ctx context.Context, id string) (bool, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return false, apierr.InvalidID("source")
	}
	if err := r.Store.DeleteSource(ctx, uid); err != nil {
		return false, apierr.SourceDeleteFailed(err)
	}
	return true, nil
}

// TriggerIndexRun is the resolver for the triggerIndexRun field.
func (r *mutationResolver) TriggerIndexRun(ctx context.Context, projectSlug string, sourceID *string) (*IndexRun, error) {
	project, err := r.Store.GetProject(ctx, projectSlug)
	if err != nil {
		if apierr.IsNotFound(err) {
			return nil, apierr.ProjectNotFound()
		}
		return nil, apierr.InternalError(err)
	}

	var sid pgtype.UUID
	if sourceID != nil {
		parsed, err := uuid.Parse(*sourceID)
		if err != nil {
			return nil, apierr.InvalidID("source")
		}
		sid = pgtype.UUID{Bytes: parsed, Valid: true}
	}

	run, err := r.Store.CreateIndexRun(ctx, postgres.CreateIndexRunParams{
		ProjectID: project.ID,
		SourceID:  sid,
	})
	if err != nil {
		return nil, apierr.IndexRunCreateFailed(err)
	}
	return dbIndexRunToGQL(run), nil
}

// Sources is the resolver for the sources field.
func (r *projectResolver) Sources(ctx context.Context, obj *Project) ([]*Source, error) {
	projectID, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, apierr.InvalidID("project")
	}
	sources, err := r.Store.ListSourcesByProjectID(ctx, projectID)
	if err != nil {
		return nil, apierr.InternalError(err)
	}
	result := make([]*Source, len(sources))
	for i, s := range sources {
		result[i] = dbSourceToGQL(s)
	}
	return result, nil
}

// IndexRuns is the resolver for the indexRuns field.
func (r *projectResolver) IndexRuns(ctx context.Context, obj *Project, limit *int) ([]*IndexRun, error) {
	projectID, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, apierr.InvalidID("project")
	}
	l := int32(10)
	if limit != nil {
		l = int32(*limit)
	}
	runs, err := r.Store.ListIndexRunsByProjectID(ctx, postgres.ListIndexRunsByProjectIDParams{
		ProjectID: projectID,
		Limit:     l,
	})
	if err != nil {
		return nil, apierr.InternalError(err)
	}
	result := make([]*IndexRun, len(runs))
	for i, ir := range runs {
		result[i] = dbIndexRunToGQL(ir)
	}
	return result, nil
}

// SymbolCount is the resolver for the symbolCount field.
func (r *projectResolver) SymbolCount(ctx context.Context, obj *Project) (int, error) {
	projectID, err := uuid.Parse(obj.ID)
	if err != nil {
		return 0, apierr.InvalidID("project")
	}
	count, err := r.Store.CountSymbolsByProject(ctx, projectID)
	if err != nil {
		return 0, apierr.InternalError(err)
	}
	return int(count), nil
}

// EdgeCount is the resolver for the edgeCount field.
func (r *projectResolver) EdgeCount(ctx context.Context, obj *Project) (int, error) {
	projectID, err := uuid.Parse(obj.ID)
	if err != nil {
		return 0, apierr.InvalidID("project")
	}
	count, err := r.Store.CountEdgesByProject(ctx, projectID)
	if err != nil {
		return 0, apierr.InternalError(err)
	}
	return int(count), nil
}

// Projects is the resolver for the projects field.
func (r *queryResolver) Projects(ctx context.Context, limit *int, offset *int) (*ProjectConnection, error) {
	principal, _ := auth.PrincipalFrom(ctx)

	l := int32(20)
	o := int32(0)
	if limit != nil {
		l = int32(*limit)
	}
	if offset != nil {
		o = int32(*offset)
	}

	projects, err := r.Store.ListProjectsByTenant(ctx, postgres.ListProjectsByTenantParams{
		TenantID: principal.TenantID,
		Limit:    l,
		Offset:   o,
	})
	if err != nil {
		return nil, apierr.ProjectListFailed(err)
	}

	total, err := r.Store.CountProjectsByTenant(ctx, principal.TenantID)
	if err != nil {
		return nil, apierr.ProjectCountFailed(err)
	}

	nodes := make([]*Project, len(projects))
	for i, p := range projects {
		nodes[i] = dbProjectToGQL(p)
	}

	return &ProjectConnection{
		Nodes:      nodes,
		TotalCount: int(total),
	}, nil
}

// Project is the resolver for the project field.
func (r *queryResolver) Project(ctx context.Context, slug string) (*Project, error) {
	principal, _ := auth.PrincipalFrom(ctx)

	p, err := r.Store.GetProject(ctx, slug)
	if err != nil {
		if apierr.IsNotFound(err) {
			return nil, apierr.ProjectNotFound()
		}
		return nil, apierr.InternalError(err)
	}
	if !principal.IsAdmin() && p.TenantID != principal.TenantID {
		return nil, apierr.Forbidden("Access denied to this project")
	}
	return dbProjectToGQL(p), nil
}

// Symbol is the resolver for the symbol field.
func (r *queryResolver) Symbol(ctx context.Context, id string) (*models.Symbol, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, apierr.InvalidID("symbol")
	}
	sym, err := r.Store.GetSymbol(ctx, uid)
	if err != nil {
		if apierr.IsNotFound(err) {
			return nil, apierr.SymbolNotFound()
		}
		return nil, apierr.InternalError(err)
	}
	return dbSymbolToGQL(sym), nil
}

// SearchSymbols is the resolver for the searchSymbols field.
func (r *queryResolver) SearchSymbols(ctx context.Context, projectSlug string, query string, kinds []models.SymbolKind, languages []string, limit *int) ([]*models.Symbol, error) {
	l := int32(20)
	if limit != nil {
		l = int32(*limit)
	}

	kindStrs := make([]string, len(kinds))
	for i, k := range kinds {
		kindStrs[i] = strings.ToLower(string(k))
	}

	rows, err := r.Store.SearchSymbols(ctx, postgres.SearchSymbolsParams{
		ProjectSlug: projectSlug,
		Query:       &query,
		Kinds:       kindStrs,
		Languages:   languages,
		Lim:         l,
	})
	if err != nil {
		return nil, apierr.InternalError(err)
	}

	result := make([]*models.Symbol, len(rows))
	for i, s := range rows {
		result[i] = dbSymbolToGQL(s)
	}
	return result, nil
}

// LineageGraph is the resolver for the lineageGraph field.
func (r *queryResolver) LineageGraph(ctx context.Context, symbolID string, depth *int, direction *LineageDirection) (*LineageGraph, error) {
	if r.Graph == nil {
		return nil, apierr.NotImplemented("Lineage graph (Neo4j not configured)")
	}

	uid, err := uuid.Parse(symbolID)
	if err != nil {
		return nil, apierr.InvalidID("symbol")
	}

	d := 3
	if depth != nil {
		d = *depth
	}

	dir := "both"
	if direction != nil {
		dir = strings.ToLower(direction.String())
	}

	result, err := r.Graph.Lineage(ctx, uid, dir, d)
	if err != nil {
		return nil, apierr.LineageQueryFailed(err)
	}

	// Convert graph.LineageNode to GQL Symbol stubs
	nodes := make([]*models.Symbol, len(result.Nodes))
	for i, n := range result.Nodes {
		nid, _ := uuid.Parse(n.ID)
		fid, _ := uuid.Parse(n.FileID)
		nodes[i] = &models.Symbol{
			ID:            nid,
			FileID:        fid,
			Name:          n.Name,
			QualifiedName: n.QualifiedName,
			Kind:          models.SymbolKind(n.Kind),
			Language:      n.Language,
		}
	}

	edges := make([]*models.SymbolEdge, len(result.Edges))
	for i, e := range result.Edges {
		sid, _ := uuid.Parse(e.SourceID)
		tid, _ := uuid.Parse(e.TargetID)
		edges[i] = &models.SymbolEdge{
			SourceID: sid,
			TargetID: tid,
			EdgeType: models.EdgeType(e.EdgeType),
		}
	}

	return &LineageGraph{
		Nodes:        nodes,
		Edges:        edges,
		RootSymbolID: symbolID,
	}, nil
}

// SemanticSearch is the resolver for the semanticSearch field.
func (r *queryResolver) SemanticSearch(ctx context.Context, projectSlug string, query string, kinds []models.SymbolKind, topK *int) ([]*SemanticSearchResult, error) {
	if r.Embed == nil {
		return nil, apierr.NotImplemented("Semantic search (embeddings not configured)")
	}

	project, err := r.Store.GetProject(ctx, projectSlug)
	if err != nil {
		if apierr.IsNotFound(err) {
			return nil, apierr.ProjectNotFound()
		}
		return nil, apierr.InternalError(err)
	}

	k := int32(20)
	if topK != nil {
		k = int32(*topK)
	}

	kindStrs := make([]string, len(kinds))
	for i, kk := range kinds {
		kindStrs[i] = strings.ToLower(string(kk))
	}

	// Embed the query
	embeddings, err := r.Embed.EmbedBatch(ctx, []string{query}, "search_query")
	if err != nil {
		return nil, apierr.EmbeddingFailed(err)
	}
	if len(embeddings) == 0 {
		return nil, apierr.EmbeddingFailed(nil)
	}

	queryVec := pgvector.NewVector(embeddings[0])

	rows, err := r.Store.SemanticSearch(ctx, postgres.SemanticSearchParams{
		ProjectID:      project.ID,
		QueryEmbedding: queryVec,
		Kinds:          kindStrs,
		Lim:            k,
	})
	if err != nil {
		return nil, apierr.SearchFailed(err)
	}

	results := make([]*SemanticSearchResult, len(rows))
	for i, row := range rows {
		// Convert distance to a score (closer = higher score)
		var score float64
		if d, ok := row.Distance.(float64); ok {
			score = 1.0 - d // cosine distance to similarity
		}
		results[i] = &SemanticSearchResult{
			Score: score,
		}
		// Store the symbol ID for the sub-resolver
		sym := dbSymbolToGQL(postgres.Symbol{
			ID:            row.ID,
			ProjectID:     row.ProjectID,
			FileID:        row.FileID,
			Name:          row.Name,
			QualifiedName: row.QualifiedName,
			Kind:          row.Kind,
			Language:      row.Language,
			StartLine:     row.StartLine,
			EndLine:       row.EndLine,
			StartCol:      row.StartCol,
			EndCol:        row.EndCol,
			Signature:     row.Signature,
			DocComment:    row.DocComment,
			Metadata:      row.Metadata,
			CreatedAt:     row.CreatedAt,
			UpdatedAt:     row.UpdatedAt,
		})
		results[i].Symbol = sym
	}

	return results, nil
}

// ColumnLineage is the resolver for the columnLineage field.
func (r *queryResolver) ColumnLineage(ctx context.Context, columnID string, depth *int, direction *LineageDirection) (*ColumnLineageGraph, error) {
	if r.Lineage == nil {
		return nil, apierr.NotImplemented("Column lineage (not configured)")
	}

	uid, err := uuid.Parse(columnID)
	if err != nil {
		return nil, apierr.InvalidID("column")
	}

	d := 5
	if depth != nil {
		d = *depth
	}

	dir := "both"
	if direction != nil {
		dir = strings.ToLower(direction.String())
	}

	result, err := r.Lineage.QueryColumnLineage(ctx, uid, dir, d)
	if err != nil {
		return nil, apierr.LineageQueryFailed(err)
	}

	nodes := make([]*ColumnLineageNode, len(result.Nodes))
	for i, n := range result.Nodes {
		nodes[i] = &ColumnLineageNode{
			ID:            n.ID,
			Name:          n.Name,
			QualifiedName: n.QualifiedName,
			TableName:     n.TableName,
			Kind:          n.Kind,
		}
	}

	edges := make([]*ColumnLineageEdge, len(result.Edges))
	for i, e := range result.Edges {
		edges[i] = &ColumnLineageEdge{
			SourceID:       e.SourceID,
			TargetID:       e.TargetID,
			DerivationType: e.DerivationType,
			Expression:     &e.Expression,
		}
	}

	return &ColumnLineageGraph{
		Nodes:        nodes,
		Edges:        edges,
		RootColumnID: columnID,
	}, nil
}

// ImpactAnalysis is the resolver for the impactAnalysis field.
func (r *queryResolver) ImpactAnalysis(ctx context.Context, symbolID string, changeType *ChangeType, maxDepth *int) (*ImpactAnalysisResult, error) {
	if r.Impact == nil {
		return nil, apierr.NotImplemented("Impact analysis (not configured)")
	}

	uid, err := uuid.Parse(symbolID)
	if err != nil {
		return nil, apierr.InvalidID("symbol")
	}

	ct := "modify"
	if changeType != nil {
		ct = strings.ToLower(changeType.String())
	}

	d := 5
	if maxDepth != nil {
		d = *maxDepth
	}

	result, err := r.Impact.Analyze(ctx, uid, ct, d)
	if err != nil {
		return nil, apierr.LineageQueryFailed(err)
	}

	root := &ImpactSymbol{
		ID:            result.Root.ID,
		Name:          result.Root.Name,
		QualifiedName: result.Root.QualifiedName,
		Kind:          result.Root.Kind,
		Language:      result.Root.Language,
	}

	gqlChangeType := ChangeTypeModify
	if changeType != nil {
		gqlChangeType = *changeType
	}

	direct := make([]*ImpactNode, len(result.DirectImpact))
	for i, n := range result.DirectImpact {
		direct[i] = impactNodeToGQL(n)
	}

	transitive := make([]*ImpactNode, len(result.TransitiveImpact))
	for i, n := range result.TransitiveImpact {
		transitive[i] = impactNodeToGQL(n)
	}

	return &ImpactAnalysisResult{
		Root:             root,
		ChangeType:       gqlChangeType,
		DirectImpact:     direct,
		TransitiveImpact: transitive,
		TotalAffected:    result.TotalAffected,
	}, nil
}

// ID is the resolver for the id field.
func (r *symbolResolver) ID(ctx context.Context, obj *models.Symbol) (string, error) {
	return obj.ID.String(), nil
}

// File is the resolver for the file field.
func (r *symbolResolver) File(ctx context.Context, obj *models.Symbol) (*models.File, error) {
	f, err := r.Store.GetFile(ctx, obj.FileID)
	if err != nil {
		return nil, apierr.InternalError(err)
	}
	return dbFileToGQL(f), nil
}

// IncomingEdges is the resolver for the incomingEdges field.
func (r *symbolResolver) IncomingEdges(ctx context.Context, obj *models.Symbol, types []models.EdgeType) ([]*models.SymbolEdge, error) {
	edges, err := r.Store.GetIncomingEdges(ctx, obj.ID)
	if err != nil {
		return nil, apierr.InternalError(err)
	}
	return filterEdges(edges, types), nil
}

// OutgoingEdges is the resolver for the outgoingEdges field.
func (r *symbolResolver) OutgoingEdges(ctx context.Context, obj *models.Symbol, types []models.EdgeType) ([]*models.SymbolEdge, error) {
	edges, err := r.Store.GetOutgoingEdges(ctx, obj.ID)
	if err != nil {
		return nil, apierr.InternalError(err)
	}
	return filterEdges(edges, types), nil
}

// ID is the resolver for the id field.
func (r *symbolEdgeResolver) ID(ctx context.Context, obj *models.SymbolEdge) (string, error) {
	return obj.ID.String(), nil
}

// Source is the resolver for the source field.
func (r *symbolEdgeResolver) Source(ctx context.Context, obj *models.SymbolEdge) (*models.Symbol, error) {
	sym, err := r.Store.GetSymbol(ctx, obj.SourceID)
	if err != nil {
		return nil, apierr.InternalError(err)
	}
	return dbSymbolToGQL(sym), nil
}

// Target is the resolver for the target field.
func (r *symbolEdgeResolver) Target(ctx context.Context, obj *models.SymbolEdge) (*models.Symbol, error) {
	sym, err := r.Store.GetSymbol(ctx, obj.TargetID)
	if err != nil {
		return nil, apierr.InternalError(err)
	}
	return dbSymbolToGQL(sym), nil
}

// File returns FileResolver implementation.
func (r *Resolver) File() FileResolver { return &fileResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Project returns ProjectResolver implementation.
func (r *Resolver) Project() ProjectResolver { return &projectResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Symbol returns SymbolResolver implementation.
func (r *Resolver) Symbol() SymbolResolver { return &symbolResolver{r} }

// SymbolEdge returns SymbolEdgeResolver implementation.
func (r *Resolver) SymbolEdge() SymbolEdgeResolver { return &symbolEdgeResolver{r} }

type fileResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type projectResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type symbolResolver struct{ *Resolver }
type symbolEdgeResolver struct{ *Resolver }
